{"/artbox-docs/folder/":{"data":{"":"","#":"Introduction Welcome to this series of guides designed for those who are new to Linux and want to explore its capabilities. Whether you’re wondering what Linux is, how to navigate its different distributions, or looking to master essential tools like Git, Debian, and Clonezilla for backups, these guides will help you get started. Each guide provides a clear, step-by-step approach to understanding and using Linux, breaking down complex concepts into simple terms."},"title":"Artbox Docs"},"/artbox-docs/folder/data/":{"data":{"":"","#":"Introduction This guide explains how to manage the ‘gimp-data’ submodule within the Artbox project. A submodule is a repository embedded within another repository. It is not a simple nested folder but a distinct repository with its own version control. The parent project is sometimes referred to as a superproject.\nArtbox Repository: The parent project, it references a commit in gimp-data. gimp-data: The submodule that points to a different repository. Understanding the Submodule Artbox Build Repository: This is the parent repository that contains the ‘gimp-data’ submodule. Artbox Data Submodule: The directory within the Artbox repository that links to the Artbox data repository. Specific Commit in Artbox Data: The submodule is fixed to a specific commit in the Artbox data repository. .gitmodules File: This file in the parent repository specifies the submodule’s repository location. graph LR;\rsubgraph Parent Repo / Superproject\rA([Artbox Build Repository])\rD([.gitmodules File])\rend\rB([Artbox Data Submodule])\rC([Specific Commit in Artbox Data Repository])\rA --\u003e B\rB --\u003e C\rD -.-\u003e BDiagram 1: This diagram illustrates the relationship between the Artbox build repository (superproject), the gimp-data submodule, and its specific commit. The .gitmodules file specifies the submodule details.\nCustomizing the Submodule Configuration: You can configure the submodule to point to a different repository, such as a modified clone of gimp-data. Updating the Superproject: After pushing changes to the new repository, update the parent repository to point to the new commit. Remotes Ensure the submodule remotes are correctly set up. For example:\ngit remote -v gimp-data-origin https://gitlab.gnome.org/GNOME/gimp-data.git (fetch) gimp-data-origin https://gitlab.gnome.org/GNOME/gimp-data.git (push) origin git@ssh.gitlab.gnome.org:pixelmixer/artbox-data.git (fetch) origin git@ssh.gitlab.gnome.org:pixelmixer/artbox-data.git (push) This set up has the GIMP gimp-data as an upstream remote called gimp-data-origin, this is used to fetch updates from GIMP.\nThe .gitmodules file in the parent repo should be adjusted to point at the Artbox gimp-data repo:\n[submodule \"gimp-data\"]\rpath = gimp-data\rurl = https://gitlab.gnome.org/pixelmixer/artbox-data.git\rshallow = true The contents of the .gitmodules file in the build/artbox folder.\nArtbox Data The Artbox ‘gimp-data’ repository is a clone of the original ‘gimp-data’ repository, with merged changes specifically for Artbox. Regularly rebasing to the upstream ‘gimp-data’ repository ensures that you incorporate the latest GIMP updates. Follow these steps to rebase:\nCheckout the ‘convert-to-artbox’ Branch: Switch to the branch that integrates the latest changes and serves as the base for your updates.\ngit checkout convert-to-artbox Update the Submodule: Make sure the submodule is synchronized with the latest commit in the ‘gimp-data’ repository.\ngit submodule update Checkout the ‘main’ Branch in the ‘gimp-data’ Directory: Navigate to the ‘gimp-data’ submodule and switch to its main branch.\ncd gimp-data git checkout main Fetch the Latest Changes from the Original ‘gimp-data’ Repository: Retrieve updates from the upstream repository to keep your local copy current.\ngit fetch gimp-data-origin Rebase the Artbox Data Repository onto the Original ‘gimp-data’: Apply the latest changes from the upstream repository onto your local branch.\ngit rebase gimp-data-origin/main Resolve Conflicts and Push Updates to the Artbox Data Repository: If there are conflicts, resolve them, and then push the rebased changes to the Artbox data repository.\ngit push -f Explanation: By rebasing the Artbox ‘gimp-data’ repository onto the original ‘gimp-data’, you ensure that your project benefits from the latest updates and improvements. Regular rebasing helps avoid conflicts and keeps the repository in sync with upstream changes.\nModifying or Adding New Resources To change or add new resources in the ‘gimp-data’ submodule, follow these steps:\nCheckout the ‘convert-to-artbox’ Branch: Ensure you are working on the correct branch that incorporates the latest changes.\ngit checkout convert-to-artbox Update the Submodule: Sync the submodule to ensure it is pointing to the latest commit in the ‘gimp-data’ repository.\ngit submodule update Checkout the ‘main’ Branch in the ‘gimp-data’ Directory: Switch to the main branch of the submodule where you will make changes.\ncd gimp-data git checkout main Make the Necessary Changes to the Data: Edit or add files as needed within the ‘gimp-data’ submodule.\nStage the Modified Files: Add the changes to the staging area for the submodule.\ngit add . Commit the Changes: Commit the staged changes with a descriptive message.\ngit commit -m \"Describe your changes here\" Push the Changes to the Artbox Data Repository: Push the updates to the remote repository of the submodule.\ngit push Update the Parent Repository: Ensure the Artbox parent repository is updated to reflect the new commit in the ‘gimp-data’ submodule.\ncd .. git add gimp-data git commit -m \"Update submodule to latest commit\" git push Explanation: This sequence ensures that changes are correctly made and integrated into both the submodule and the parent repository. By committing and pushing changes in the submodule first, and then updating the parent repository, you maintain proper synchronization and history.\nPropagating Changed Data to Feature Branches To ensure that the changed data in the submodule is reflected in your feature branches, follow these steps:\nCheckout the Feature Branch: Switch to the branch where you want to propagate the changes.\ngit checkout feature-branch Rebase the Branch: Rebase the feature branch onto the common base layer to incorporate the latest commit from the ‘convert-to-artbox’ branch. This step ensures that your feature branch is up-to-date with the latest changes.\ngit rebase convert-to-artbox Update the Submodule: After rebasing, update the submodule to ensure it points to the correct commit in the ‘gimp-data’ repository. This step integrates any changes made to the submodule.\ngit submodule update --remote Push the Changes: Push the updated feature branch to the remote repository, reflecting the integrated changes.\ngit push "},"title":"Data"},"/artbox-docs/folder/technical-guide/":{"data":{"":"","#":"","branch-development-flow-for-gimp-to-artbox#Branch Development Flow for GIMP to Artbox":"Introduction The diagram illustrates the flow of the development process. The GIMP development branch is the foundation, and the ‘convert-to-artbox’ branch serves as the common base for all feature branches. These feature branches contribute to the final ‘Artbox’ branch, which represents the integrated work from all features.\nContents Updating Artbox to GIMP Dev Step 1: Construct the Common Base Step 2: Construct Feature Branches from the Common Base Step 3: Construct Artbox from the Common Base and Feature Branches Convert Branches Example of a Compound Convert Branch: convert-paintbrush-all-merged Feature Branches Example of a Compound Feature Branch: feature-paintbrush-options Notes Branch Development Flow for GIMP to Artbox graph LR;\rA([GIMP Dev])\rB([Convert to Artbox])\rC([Feature A])\rD([Feature B])\rE([Feature C])\rF([Artbox])\rA --\u003e B\rB --\u003e C\rB --\u003e D\rB --\u003e E\rC --\u003e F\rD --\u003e F Diagram 4: This diagram illustrates the flow from the GIMP Dev branch to the final Artbox branch. The ‘convert-to-artbox’ branch is created from GIMP Dev, and it supports the development of multiple feature branches. Each feature branch, originates from the common ‘convert-to-artbox’ base branch. Finally, the individual feature branches merge into the ‘artbox’ branch\nUpdating Artbox to GIMP Dev To keep Artbox up-to-date with the GIMP development branch, we follow a structured process divided into three main steps\nStep 1: Construct the Common Base Reset the Common Base: Reset the ‘convert-to-artbox’ branch to the latest commit from the GIMP master branch. Merge Convert Branches: Merge all relevant convert branches into the ‘convert-to-artbox’ branch. Squash Commit History: Squash the commit history of these merges into a single commit to simplify history. Step 2: Construct Feature Branches from the Common Base Update the Common Base: Ensure that the ‘convert-to-artbox’ branch is up to date with the latest changes. Clone and Layer Commits: Clone the ‘convert-to-artbox’ branch. Pick and apply commits from each existing feature branch onto this clone. Replace Old Feature Branches: Delete the old feature branches. Rename the cloned branches to replace the old feature branches. Repeat for All Feature Branches: Perform the above steps for each feature branch that needs updating. Step 3: Construct Artbox from the Common Base and Feature Branches Reset Artbox Branch: Reset the ‘artbox’ branch to the ‘convert-to-artbox’ branch to incorporate the latest changes. Merge Updated Feature Branches: Merge all updated feature branches into the ‘artbox’ branch to consolidate the changes. Convert Branches A convert branch is used to adjust the latest GIMP master branch to support the Artbox feature branches or to make specific changes to the default GIMP application. These branches are merged into a single ‘convert-to-artbox’ branch, which serves as the common base layer.\nThe current strategy is to place any heavily modified file that supports multiple feature branches—through the addition of new data structures—into a convert branch. This approach helps consolidate overlapping changes in one place, while maintaining the core code that performs the main functions in separate feature branches.\nThe convert branches are:\nconvert-to-artbox: The main branch that combines all other convert branches. convert-data-remote: Handles the gimp-data remote url. convert-context-all-merged: Consolidates context-related changes. convert-paintbrush-all-merged: Integrates modifications to the paintbrush tool. convert-pref-all-merged: Merges changes to preferences. convert-force-artbox-config: Forces specific configuration settings for Artbox. convert-name: Manages naming of Artbox. convert-readme: Updates the README.md Updating Artbox: Identifying Conflicts The first stage of updating Artbox to the GIMP development branch involves identifying any conflicts or changes introduced by GIMP that overlap with Artbox changes. These conflicts can then be resolved at this early stage.\nExample of a Compound Convert Branch: convert-paintbrush-all-merged A convert branch like ‘convert-paintbrush-all-merged’ is itself a combined branch that integrates multiple smaller changes.\nconvert-paintbrush-all-merged: Integrates modifications to the paintbrush tool. convert-paintbrush-simple-boundary convert-paintbrush-simple-boundary convert-paintbrush-status-alt convert-paintbrush-erase convert-paintbrush-has-alpha convert-paintbrush-has-alpha convert-paintbrush-erasing-paint convert-paintbrush-erasing-paint These sub-branches implement smaller, specific changes. If a conflict arises between convert-paintbrush-all-merged and the GIMP development branch, the sub-branch can be reset to align with the latest GIMP development version, and the minor adjustment can be reapplied as needed.\nFeature Branches A feature branch may also serve as an integration branch to consolidate multiple related changes. For example, the branch feature-paintbrush-options is composed of several smaller branches that have been merged together. This approach allows conflicts to be resolved incrementally, reducing complexity during the final merge into the main branch.\nExample of a Compound Feature Branch: feature-paintbrush-options feature-paintbrush-options options-paintbrush-order options-paintbrush-separate-dynamics options-paintbrush-compact-resource-view options-paintbrush-remove-link-brush options-paintbrush-remove-reset-brush options-paintbrush-additional-expander convert-to-artbox These merged sub-branches appear as individual commits in the feature-paintbrush-options branch commit history, after the commit labeled “convert to artbox.”\ngit checkout feature-paintbrush-options\rgit log\rcommit \u003cSHA\u003e (HEAD -\u003e feature-paintbrush-options)\rMerge branch 'options-paintbrush-order'\rcommit \u003cSHA\u003e\rMerge branch 'options-paintbrush-separate-dynamics'\rcommit \u003cSHA\u003e\rMerge branch 'options-paintbrush-compact-resource-view'\rcommit \u003cSHA\u003e\rMerge branch 'options-paintbrush-remove-link-brush'\rcommit \u003cSHA\u003e\rMerge branch 'options-paintbrush-remove-reset-brush'\rcommit \u003cSHA\u003e\rMerge branch 'options-paintbrush-additional-expander'\rcommit \u003cSHA\u003e\rconvert to artbox Notes The key difference between a feature branch and a convert branch is that feature branches, and their sub-branches, build on top of the convert-to-artbox branch. In contrast, a convert branch is an adjustment made directly to the GIMP development master branch."},"title":"Technical-Guide"},"/artbox-docs/folder/troubleshooting/":{"data":{"":"","gimp-data#gimp-data":"Troubleshooting Install and Build Deleting the _build directory Causes a Meson Fail Occasionally, to get GIMP building correctly, you may need to delete the _build directory Meson creates, note the ‘_’. Do not delete the ‘build’ directory! This clears all the old build data and allows a fresh try. However, if you use --wipe or --reconfigure in your build process, and the _build directory is not present or empty, Meson may fail. This could be because Meson requires the _build directory to be present and contain a valid build configuration in order to reconfigure or wipe the build.\nAvoiding the Issue To avoid this issue, make sure to create the _build directory and run Meson at least once without –wipe or –reconfigure before attempting to change the compiler. This will ensure that the _build directory contains a valid build configuration, and Meson will be able to reconfigure or wipe the build successfully. Alternatively, we can do a check in the build script for this event.\nload error: libavcodec.so.61: If you see error messages like this during start up, it’s because we need a newer version of a particular library than the one packaged with the Linux distribution we are using.\nGEGL-Message: 20:50:10.029: Module '/home/mark/code/gnome/lib/x86_64-linux-gnu/gegl-0.4/ff-save.so' load error: libavcodec.so.61: cannot open shared object file: No such file or directory For me, this issue was solved by building the latest version of FFmepg, which includes the needed library, libavcodec.so.61.\nInstall a needed library prior to the build process:\nsudo apt-get install libx264-dev Create a local folder for FFMpeg, open a terminal in that folder, then:\ngit clone https://git.ffmpeg.org/ffmpeg.git cd ffmpeg ./configure --enable-shared --enable-gpl --enable-libx264 --enable-libx265 --disable-x86asm --disable-libopus Now we make and install:\nsudo make install Verify you have the latest version:\nls /usr/local/lib | grep libavcodec\rlibavcodec.a\rlibavcodec.so\rlibavcodec.so.61\rlibavcodec.so.61.11.100 When building and launching Artbox, those GEGL error messages should be gone.\nEDIT: discovered that this could have been caused by a rougue use of submodule update in the gegl folder.\nGEGL or BABL issues A build error may occur if we haven’t built BABL or GEGL for a while and there is a new feature used by GIMP, and therefore Artbox, that is not available locally. We need to get the latest version of BABL and GEGL then rebuild those libraries.\nThis sequence of git instructions will reset your local babl and gegl folders to be a clone of the remote folders. WARNING: Any changes you made locally in the master folder, will be lost.\ncd $GIMP_PREFIX/build/gegl git checkout master git fetch origin git reset --hard origin/master git clean -df cd $GIMP_PREFIX/build/babl git checkout master git fetch origin git reset --hard origin/master git clean -df Remember to be careful when resetting your local repositories, as any local changes you may have made will be lost.\nRebuild BABL and GEGL using the previously described build script:\nbuild_babl=\"true\" build_gegl=\"true\" gimp-data When performing a rebase on a branch that includes submodules, Git may fail with a conflict related to submodule merging. The error may look like this:\nFailed to merge submodule gimp-data CONFLICT (submodule): Merge conflict in gimp-data Recursive merging with submodules currently only supports trivial cases. This issue occurs because Git does not handle complex submodule merging automatically during a rebase, especially when the submodule contains conflicting changes. If you encounter this error during a rebase, you can bypass the submodule conflict by restoring the submodule’s staged state and continuing with the rebase:\nWorkaround:\nThis will remove the submodule (e.g., gimp-data) from the rebase process, allowing you to continue:\ngit restore ---staged gimp-data Once you’ve restored the submodule’s staged state, continue with the rebase process:\ngit --continue Explanation The git restore –staged gimp-data command effectively resets the submodule to its previous state, removing it from the list of files that are considered to have conflicts. This allows Git to move forward with the rebase without attempting to handle the submodule as part of the conflict resolution process.\nPlease let me know any issues and solutions you discover, thanks.","troubleshooting#Troubleshooting":""},"title":"Troubleshooting"},"/blog/":{"data":{"":" "},"title":"Blog"},"/docs/folder/Artbox-Installing/":{"data":{"":"","#":"","clone-the-source-code-repositories#Clone the Source Code Repositories":"Introduction Artbox is a modified version of GIMP, if you can build GIMP, you can build Artbox. Artbox does not exist as an individual application, it relies on many parts to function and many apps are used to construct it. You need to create a build environment for it first, like an aquarium for a fish. The following is a guide, for a Debian system. It will be a unique process for your system, and may require further research. Good luck!\nContent Git Dependencies Install Location Clone the Source Code Repositories Environment Variables A Build Script for Artbox, BABL and GEGL Desktop Launcher (System Specific) Conclusion Git Before we dive into building Artbox, you’ll need to install and learn the basics of Git, a version control system that helps you manage and share source code. Git is an essential tool for any developer, and understanding how to use it will make the rest of the build process much easier. If you’re new to Git, take a few minutes to read through A Beginner’s Guide to Using Git on Linux to get up to speed.\nDependencies Here is the official guide. The suggestion to look at this file, that builds GIMP in the GitLab CI environment, is worth following. That file lists all the dependencies the GIMP Dev build process needs. By using that information we can make a bash script to install those packages on our system. Save the following code block to a file called “install-GIMP-dep.sh” and execute it by following the instructions below.\nTo execute the script:\nOpen a terminal in the script folder. Run the command bash install-GIMP-dep.sh to execute the script. Important: Be wary about executing shell scripts from the internet, have a look at the contents and try and understand roughly what it is doing. Alternatively copy it into an AI chatbot and ask that what the script is doing.\n#!/bin/bash # Define the list of packages to install PACKAGES=( ccache clang cmake lld libomp-dev appstream at-spi2-core desktop-file-utils ffmpeg gettext ghostscript gi-docgen git gjs glib-networking gobject-introspection graphviz graphviz-dev hicolor-icon-theme iso-codes libaa1-dev libappstream-glib-dev libbz2-dev libcfitsio-dev libdbus-glib-1-dev libexif-dev libgexiv2-dev libgirepository1.0-dev libgs-dev libgtk-3-bin libgtk-3-dev libgudev-1.0-dev libheif-dev libjson-glib-dev libjxl-dev liblcms2-dev liblzma-dev libmng-dev libmypaint-dev libopenexr-dev libopenjp2-7-dev libpoppler-glib-dev libraw-dev libraw20 librsvg2-dev libspiro-dev libsuitesparse-dev libtiff-dev libtiff5-dev libtool libumfpack5 libunwind-dev libwebp-dev libwmf-dev libxmu-dev libxpm-dev luajit meson mypaint-brushes poppler-data python3 python3-gi valac xauth xsltproc xvfb xz-utils yelp-tools ) # Define a function to install a package and report failure install_package() { local package=\"$1\" if sudo apt-get install -y \"$package\"; then echo \"Installed $package\" else FAILED_PACKAGES+=(\"$package\") fi } # Initialize the list of failed packages FAILED_PACKAGES=() # Loop through the packages and install them for package in \"${PACKAGES[@]}\"; do install_package \"$package\" done # Print a summary of the installation echo \"\" echo \"Installation Summary:\" echo \"---------------------\" echo \"Installed packages: ${#PACKAGES[@]}\" echo \"Failed packages: ${#FAILED_PACKAGES[@]}\" if [ ${#FAILED_PACKAGES[@]} -gt 0 ]; then echo \"Failed packages:\" for package in \"${FAILED_PACKAGES[@]}\"; do echo \" $package\" done fi read -n 1 -r -s -p \"Press any key to exit\" Install Location After the Git challenge and package installation, we can proceed with the task. We’ll keep the files we need in repository folders on the hard-drive, it’s good to call the root folder “code”, then put in a sub-folder, like “gnome”, then another sub-folder “build” and one called “bash”\nHome code bash gnome build These shell commands will create that little structure when run in a terminal, or you can do it using the File Manager.\nmkdir $HOME/code mkdir $HOME/code/bash mkdir $HOME/code/gnome mkdir $HOME/code/gnome/build We are now ready to download from the internet, the source code files we need for our build environment. These files will be cloned from existing repositories using Git and GitLab addresses.\nClone the Source Code Repositories In a terminal we can download the sources to our build directory:\ncd $HOME/code/gnome/build git clone https://gitlab.gnome.org/GNOME/babl git clone https://gitlab.gnome.org/GNOME/gegl git clone https://gitlab.gnome.org/GNOME/gimp git clone https://gitlab.gnome.org/pixelmixer/artbox.git The simple folder structure is now populated with thousands of files, and there’s more to be made automatically by the build process.\nHome code bash gnome build babl gegl gimp artbox Environment Variables The software that is about to be built, needs to know a few things about its environment. We do this by exporting some environmental variables. Copy the following into a file, call it build_env.sh and save it in the “bash” folder.\n#!/usr/bin/env bash export GIMP_PREFIX=\"${HOME}/code/gnome\" export PATH=\"$GIMP_PREFIX/bin:$PATH\" # Capture the multi-os-directory multi_os_directory=$(gcc -print-multi-os-directory 2\u003e/dev/null) if echo \"$multi_os_directory\" | grep ./ \u003e /dev/null; then LIB_DIR=$(echo \"$multi_os_directory\" | sed 's/\\.\\.\\///g') else LIB_DIR=\"lib\" fi # Capture the multiarch multiarch=$(gcc -print-multiarch 2\u003e/dev/null) if echo \"$multiarch\" | grep . \u003e /dev/null; then LIB_SUBDIR=\"${multiarch}/\" else LIB_SUBDIR=\"\" fi # Export environment variables export PKG_CONFIG_PATH=\"${GIMP_PREFIX}/${LIB_DIR}/${LIB_SUBDIR}pkgconfig${PKG_CONFIG_PATH:+:$PKG_CONFIG_PATH}\" export LD_LIBRARY_PATH=\"${GIMP_PREFIX}/${LIB_DIR}/${LIB_SUBDIR}${LD_LIBRARY_PATH:+:$LD_LIBRARY_PATH}\" export XDG_DATA_DIRS=\"${GIMP_PREFIX}/share:/usr/share${XDG_DATA_DIRS:+:$XDG_DATA_DIRS}\" export GI_TYPELIB_PATH=\"${GIMP_PREFIX}/${LIB_DIR}/${LIB_SUBDIR}girepository-1.0${GI_TYPELIB_PATH:+:$GI_TYPELIB_PATH}\" A Build Script for Artbox, BABL and GEGL To build or run the software, we can use another shell script, that uses this file to build, compile or run the software. Copy the following and save it as artbox.sh in the bash folder. Then in your File Manager, right click the artbox.sh file, properties, permissions, “Allow executing file as program”.\nNotice that BABL and GEGL are also being built, these two additional packages don’t have to be built everytime.\n#!/usr/bin/env bash # sets the type of build \"release\" or \"debug build_type=\"release\" # set to \"false\" to skip the build build_babl=\"true\" build_gegl=\"true\" build_artbox=\"true\" # code changes can be compiled and tested, rather than building everything compile_artbox=\"false\" # find the directory this script was run in script_dir=\"$(dirname \"$(realpath \"$0\")\")\" # load the environment variables source \"$script_dir/build_env.sh\" # start in the build directory cd ${GIMP_PREFIX}/build/ # Build and install BABL if [ $build_babl == \"true\" ]; then mkdir -p babl/_build \u0026\u0026 cd babl/_build meson setup .. -Dprefix=\"${GIMP_PREFIX}\" ninja ninja install echo -e \"\\n*** Built BABL ***\\n\" fi # start in the build directory cd ${GIMP_PREFIX}/build/ # Build and install GEGL if [ $build_gegl == \"true\" ]; then mkdir -p gegl/_build \u0026\u0026 cd gegl/_build meson setup .. -Dprefix=\"${GIMP_PREFIX}\" ninja ninja install echo -e \"\\n*** Built GEGL ***\\n\" fi # start in the build directory cd ${GIMP_PREFIX}/build/ # Build and install Artbox if [ $build_artbox == \"true\" ]; then mkdir -p artbox/_build cd artbox/_build # Construct a build command MESON_SETUP=\"meson setup .. -Dprefix=${GIMP_PREFIX} --buildtype=$build_type\" # if the build directory has configuration files, then wipe for a clean build if [ -e meson-logs ]; then MESON_SETUP+=\" --wipe\" fi $MESON_SETUP ninja ninja install echo -e \"\\n*** Built Artbox ***\\n\" fi # compile if [ $compile_artbox == \"true\" ]; then cd ${GIMP_PREFIX}/build/artbox/_build ninja ninja install echo -e \"\\n*** Compiled Artbox ***\\n\" fi read -n 1 -r -s -p \"Press any key to exit...\" To run the build script you can open a terminal in the bash folder and enter: bash artbox.sh\nDesktop Launcher (System Specific) Alternatively you can launch Artbox using a desktop launcher, save the following as a file to your desktop, and then right click it, properties, permissions, “Allow executing file as program”.\n[Desktop Entry] Exec=gnome-terminal -- /home/your-home/code/bash/artbox.sh Terminal=True Icon=cinnamon-panel-launcher Type=Application Name[en_GB]=Artbox You’ll have to change “your-home” to get it to work, this is a Linux thing, on my system the line would be:\ngnome-terminal -- /home/mark/code/bash/artbox.sh It also assumes you are using a specific desktop environment (Cinnamon). My tip would be to look at how to create a desktop launcher for your particular system, or copy and edit an existing one you may have.\nConclusion At this point you will have the source code for Artbox, a build script and a desktop launcher. Double clicking the launcher should see a terminal and Artbox will open. There are many ways to make a build script, this is a starting point. If you got to this point, congratulations!\nYou can also build GIMP in the same manner, replace occurrences of “artbox” in the build script to “gimp”."},"title":"Installing"},"/example/folder/":{"data":{"":"folder _index.md contents"},"title":"example/folder/_index.md"},"/example/folder/example-page/":{"data":{"":"example/folder/example-page.md"},"title":"example-page"},"/guides/folder/":{"data":{"":"","#":"Introduction Welcome to this series of guides designed for those who are new to Linux and want to explore its capabilities. Whether you’re wondering what Linux is, how to navigate its different distributions, or looking to master essential tools like Git, Debian, and Clonezilla for backups, these guides will help you get started. Each guide provides a clear, step-by-step approach to understanding and using Linux, breaking down complex concepts into simple terms."},"title":"Guides"},"/guides/folder/a-linux-system-overview/":{"data":{"":"","#":"Introduction Linux is a powerful and versatile operating system with a vast community of developers. At its core, a Linux system consists of several key components that work together to provide a seamless user experience. This overview will outline the essential parts of a Linux system, including the kernel, distribution, package manager, display manager, desktop environment, and display server (X11 or Wayland).\nExamples of Linux Distribution Configurations Distribution Package Manager Display Manager Desktop Environment Display Server Debian APT GDM GNOME X11 Debian APT LightDM Cinnamon X11 Debian Testing APT GDM GNOME Wayland Fedora DNF GDM GNOME Wayland Arch Linux Pacman SDDM KDE Plasma X11 Explanation Kernel The core of the operating system that interfaces directly with the hardware, usually Linux.\nDistribution The Linux distribution, which packages the kernel along with user space tools, libraries, and software. Examples include Debian, Arch Linux, and Fedora.\nPackage Manager A tool used to install, update, and remove software applications from repositories. Examples include APT for Debian-based distributions, DNF for Fedora, and Pacman for Arch Linux.\nDisplay Manager Manages the graphical login screen and session initiation. Examples include GDM (GNOME Display Manager), LightDM, and SDDM (Simple Desktop Display Manager).\nDesktop Environment Provides the graphical user interface (GUI) and manages the overall appearance and user experience. Examples include GNOME, Cinnamon, and KDE Plasma.\nDisplay Server Manages the display output and input events. Examples include X11 (X Window System) and Wayland. X11 is a traditional display server, while Wayland is a newer, more secure alternative."},"title":"A-Linux-System-Overview"},"/guides/folder/installing-debian/":{"data":{"":"","#":"Introduction This document outlines the steps I took to install Debian Stable as the Artbox OS. It may be useful for others attempting a similar installation. Debian Stable was chosen as the Linux platform because GIMP Dev is built on Debian Testing and aims to support building GIMP on Debian Stable.\nBackup Your Data Before installing Debian, make a complete backup of your Home directory on an external drive. Include any other data folders and files you want to keep. If you have Git repositories, push any wanted changes to the origins to easily restore them after the install. Any unsaved data will be lost.\nCreate a Partition Create a disk partition on your primary hard drive to install Debian onto. This process has many online guides and various tools, such as GParted. You may need to create a partition from Windows to create a dual-boot machine or reuse an existing partition for Linux. Understand the process specific to your system and needs before proceeding.\nCreate a USB to Install Debian Stable Assuming you have created a partition on your primary hard drive for Debian and an appropriate-sized swap partition:\nDownload the Debian ISO from the official website. On Windows, we can use BalenaEtcher to put the ISO on a USB drive. On Linux, we can use a command-line tool to create a bootable USB from the ISO. Install Insert the USB drive into a main USB port. Restart and press F2 on the initial screen to access the boot options. Select the USB drive to boot from. Choose a non-graphical install. Skip the root password when asked, leaving it blank, and set a user password on the next section. Partition manually: Set your spare partition as ext4 journaling. Set your swap partition. Mount point: / Label: linux Hostname: name (appears to the right of your terminal prompt user@hostname) User account: Your Full Name User: name (appears to the left of your terminal prompt) Add Cinnamon to the install section for a traditional desktop interface. The installation will proceed, and you should have a new Debian Stable OS to set up. Setup the System Display Scaling You may have purchased a 4K monitor to use 4K worth of display, at the moment, Debian Stable does not do fractional scaling in a way that allows this.\nAn ideal approach to display scaling would be, where the display resolution is retained, and only the GUI elements are scaled up or down to match the desired size. This is often referred to as “resolution-independent” or “high-DPI” scaling.\nIn this approach, the display resolution remains the same (e.g., 4K), and the GUI elements, such as text, icons, and graphics, are scaled up or down to match the desired size. This way, the display resolution is not compromised, and the GUI elements are rendered at a size that’s comfortable for the user.\nUnfortunately, Linux desktop environments have been slower to adopt this approach, and many still use the older method of scaling the display resolution itself, which can lead to the blurriness.\nAvoid fractional display scaling, as Debian Stable does not support it well. Instead, use the following workaround: Menu -\u003e Search -\u003e Font Selection -\u003e Font Settings -\u003e Text Scaling Factor -\u003e 2.5 Menu -\u003e Search -\u003e Font Selection -\u003e Desktop Font 14: affects both monitors Menu -\u003e Search -\u003e Panel -\u003e Customize -\u003e Panel Height 60 Menu -\u003e Search -\u003e Panel -\u003e Panel appearance -\u003e Right Zone: Symbolic Icon Size 48px Menu -\u003e Search -\u003e Mouse and Touchpad -\u003e Pointer Size and Speed: affects both monitors Right-click the 4K monitor Desktop -\u003e Customize: Icon Size Larger Firefox: in the address bar -\u003e about:config -\u003e search: layout.css.devPixelsPerPx -\u003e set the value to 1 Terminal Configure your terminal to your liking:\nMenu -\u003e Search -\u003e Terminal -\u003e Edit -\u003e Preferences Text -\u003e Initial Size 140: columns 40 rows Text -\u003e Custom font: 140: Monospace 10 Colours -\u003e Built-in-schemes -\u003e Solarized Dark Restore Data - User Specific Restore your backed-up data to the Home directory. For example:\nBackup/Home/Artwork -\u003e Home/Artwork Backup/Home/code -\u003e Home/code Backup/Home/Desktop -\u003e Home/Desktop Backup/Home/.ssh (GitLab keys) -\u003e Home/.ssh (GitLab keys) Backup/Home/.config/GIMP -\u003e Home/.config/GIMP Git Install Git using the terminal command: sudo apt install git Configure your Git email: git config --global --edit\nGitLab Access Restore repository access to GitLab or GitHub:\nChange the permissions on the SSH key file: chmod 600 ~/.ssh/id_rsa Add the user to the new Git install: ssh-add ~/.ssh/id_rsa Test the connection: ssh -T git@ssh.gitlab.gnome.org or ssh -T git@github.com For each repository, fetch the origins and reset the local branch to match:\ngit reset --hard remote-name/branch-name git clean -df A git status report on the updated repo should now look normal. This may also need to be done on any submodules.\nWe now have a new OS with any data and repositories restored. This process is fairly specific to my usage and knowledge of Linux, feel free to offer any suggestions for improving it as a guide."},"title":"Installing-Debian"},"/guides/folder/system-backup-clonezilla/":{"data":{"":"","#":"Introduction It’s common to back up your important files to return to earlier versions or replace corrupted data. However, another essential type of backup is a disk clone, a complete backup of your system’s state.\nOnce you have your system set up and working well, creating a full backup is crucial for restoring your environment in case disaster strikes. This backup complements regularly saving your working data.\nClonezilla is a free and open-source disk imaging and cloning software. It allows users to create and restore full backups of their computer’s hard drive, making it a popular tool for IT professionals and home users alike.\nIt’s always better to have a backup and not need it than to need a backup and not have it.\nKey Features of Clonezilla Disk Imaging: Clonezilla creates an exact copy of a hard drive, including the operating system, applications, and data. Backup and Restore: It enables you to create a backup image of a hard drive and restore it in case of failure or migration to a new drive. Free and Open Source: Clonezilla is completely free to use, and the source code is available for modification and customization. Using Clonezilla to Backup and Restore a Debian Partition Preparation Steps You will need a USB drive for Clonezilla and an external hard drive that is larger than the internal drive you intend to clone.\nThese steps simplify the process based on the official guide. It’s a good idea to review the full guide, which includes screenshots for added clarity.\nCreate a Clonezilla Live USB or CD/DVD: Follow the detailed instructions on the Clonezilla website to create a bootable USB or CD/DVD.\nConnect Your External Backup Drive: Plug in your external drive and ensure it is recognized by your system. This will be the destination for your backup.\nVerify Your Partition Layout: Use the lsblk command in a terminal to verify the partition layout of your primary hard drive. Note the primary device name.\nBoot from Clonezilla Live USB Drive: Restart your computer and boot from the Clonezilla media you created. You may need to access your BIOS/UEFI settings (usually by pressing F2, F12, ESC, or DEL during boot) and adjust the boot order to prioritize the USB drive.\nBackup with Clonezilla Select Backup Mode: Once Clonezilla boots up, choose “device-device” mode. This mode allows you to directly clone your internal drive to an external device.\nSelect the Source Device: Choose the primary internal drive.\nSelect the Target Device: Choose your external backup drive as the target device. Be careful when selecting the device to avoid overwriting important data. Ensure that the target drive is equal to or larger in size than the source drive.\nStart the Backup Process: Clonezilla will start the backup process. Depending on the size of your partition and the speed of your drives, this could take anywhere from several minutes to a few hours.\nLabel Your Backup: After the backup is complete, label the USB drive and the external hard drive with the date, and the system you backed up. Store them in a safe place.\nRestoring from Backup If you need to restore your Debian system from the backup, follow these steps:\nBoot from Clonezilla Media: Insert the Clonezilla USB and boot from it, following the same steps as during the backup process.\nSelect Restore Mode: Choose the “device-device” mode again, but this time, you will restore from the backup image. This will copy all the data from your external drive back to your internal drive.\nSelect the Source Device: Choose your external drive where the backup is stored.\nSelect the Target Device: Select the internal drive where you want to restore the backup.\nStart the Restore Process: Clonezilla will begin the restore process. As with the backup, the time required will depend on the size of the drive and the speed of your hardware.\nFinal Notes Disk backups with Clonezilla ensure that your entire system—operating system, settings, and applications—is preserved. With minimal effort, you can safeguard your system from catastrophic failure and minimize downtime in the event of a crash.\nRemember, backups are essential. Regularly update your backups and periodically test them to ensure you can restore your system when needed.\nAfter booting, you can plug in your external backup drive and inspect its partition structure using the Disks utility in Linux. The backup drive should mirror the internal drive’s structure, with the same partitions and some unused space if the external drive is larger."},"title":"System-Backup-Clonezilla"},"/guides/folder/using-git-on-linux/":{"data":{"":"","#":"Introduction Welcome to this beginner’s guide to using Git on Linux! This guide is designed to help you get started with Git and GitLab, and to provide a basic understanding of how to use these tools.\nGit Overview The code used for making applications is kept in a collection of folders and files on your system. Git is an application that allows us to backup, share, and copy that collection. Git is known as a version control system that allows you to track changes to your code and collaborate with others. It’s a powerful tool that’s widely used in the open-source community. GitLab is a web-based platform that allows you to host and manage your Git repositories online, making it easy to collaborate with others and track changes to your code.\nWhat is a Repository? A repo, short for repository, is a Git-managed local folder with an online copy. A Git Lab repo is a collection of files and folders that make up a project. It can have branches that are independent copies of the same project. A branch is a separate version of your project that allows you to make changes without affecting the main version. This is useful for testing new features or fixing bugs without disrupting the main project. There is your local repo, stored on your hard drive, and the remote repo, stored online using Git and GitLab.\nUsing Git You’ll need to install Git on your system. On Debian-based systems, you can use the apt command to install software packages. In this case, we’re using it to install Git, which is a package that provides the Git version control system. The sudo command gives the installer permission to install on your system.\nsudo apt install git Access GitLab Before you can use GitLab, you’ll need to create an account by visiting the GitLab website and completing the registration process.\nGitLab requires SSH for secure and authenticated communication between a client (you, for instance) and the GitLab server when performing Git operations like cloning, pushing, and fetching repositories. Cloning is making a local copy of the repo, fetching is bringing any changes made in the repo to your local copy, and pushing is sending changes and content to the server repository. SSH (Secure Shell) is a network protocol that allows secure remote access and uses key pairs to authenticate and establish secure connections. To generate an SSH key pair, you can use the ssh-keygen command in your terminal.\nssh-keygen Specify a filename, or use the default by pressing Enter, and optionally a password. In your home directory, in a hidden folder called .ssh, there are now two id_rsa files, if you went with default names. The .pub file is the public key and you can see its contents with a text editor.\nLog in to your GitLab account and navigate to your user settings. Click on ‘SSH Keys’ in the left-hand navigation menu. Copy and paste your public key into the Key field and give the key a relevant title, like PC@Home. Click the ‘Add Key’ button to save the key. Your SSH public key is now added to your GitLab account and you can use it to authenticate with GitLab repositories. Test if your keys and connection are working with the ssh -T command to see a welcome message from GitLab.\n$ ssh -T git@ssh.gitlab.gnome.org Welcome to GitLab, @username! "},"title":"Using-Git-on-Linux"},"/test/folder/":{"data":{"":"","#":"Introduction These are experimental features have been added to Artbox. As with any new code, they may be unstable or require fixes and are subject to change or removal.\nRelated Sites Digital Painting\nDesign Proposals for Digital Art"},"title":"Feature Testing"},"/test/folder/filter-restores-last-tool/":{"data":{"":"","#":"Objective Removes a longstanding GUI issue.\nKey Concepts and Definitions Filter: A plug-in that processes pixels in a drawable, Hue, Blur etc. Tool Palette: The grid of tool buttons, Move Tool, Paintbrush Tool ect. Related Links Branches: Artbox and feature-filter-restores-last-tool old Merge Request Design Revisions Revision Current Design Issues Changes 1. Restore the previous tool after using a filter The filter is the active tool Confusing to the user to deselect the active tool when a filter is used, and to keep the filter as the active tool Restore the previous tool when a filter dialog is closed "},"title":"Filter-Restores-Last-Tool"},"/test/folder/paint-tool/":{"data":{"":"","#":"Objective Improve the quality of the painting experience in Artbox\nRelated Links Branches: Artbox and feature-painttool Design Revisions Revision Current Design Issues Changes 1. Easy Cursor Location The Tool Cursor can be turned off in Preferences, and the pointer, leaving the only the brush outline. This is good, but causes issues. A small and minimal cursor can be hard to locate There is a minimum screen size for the cursor, and a small ‘filled’ ‘contact’ circle is always drawn 2. Indicate Erase Mode New Feature It’s not possible to tell if the paintbrush is about to erase whilst looking at the cursor Detect the ‘Eraser Tool’ and ‘Erase Paint’ mode, change the cursor to a dashed circle 3. Simple Brush Boundary Image brushes are drawn as complex outlines based on the image They can make a distracting paintbrush when the image is large and noisy Draw a simple circular boundary if the ‘Simple Brush Boundary’ option is checked in the Paintbrush Options Notes This feature branch only works when merged with the ‘artbox’ branch or rebased onto the ‘options-paintbrush-simple-boundary’ branch"},"title":"Paint-Tool"},"/test/folder/paintbrush-high-quality-force/":{"data":{"":"","#":"Objective Improve the quality of the painting.\nKey Concepts and Definitions Brush Stamp: The mask that is used as a brush ‘stamp’. Force: A paintbrush option that affects the pre-processing of the brush stamp. Related Links Branches: Artbox and feature-paintbrush-high-quality-force Design Revisions Revision Current Design Issues Changes 1. Enable High Quality Force It is not active The Force parameter is not working as well as it could Enable Notes This feature is the wonderful work of Elle Stone. Artbox simply enables the option by default. Performance was an issue several years ago, which led to it being deactivated."},"title":"Paintbrush-High-Quality-Force"},"/test/folder/paintbrush-options/":{"data":{"":"","#":"Objective Improve the usability of the Paintbrush GUI.\nKey Concepts and Definitions Reset Brush Option: Resets the slider to a default value. Brush Link Button: Links the paintbrush options to the brush editor options. Expander: A collapsible GUI section for organizing lesser-used options. Related Links Branches: Artbox and feature-paintbrush-options Design Revisions Revision Current Design Issues Changes 1. Remove Reset Brush Button Option sliders have a reset button to default values. Rarely used; adds complexity to the GUI. Remove the reset to default button. 2. Remove Brush Link Button Brush link button allows linking to brush editor options. Difficult to explain and justify; causes confusion Remove the link button. 3. Add Expander for Additional Options Options added to the end of paintbrush settings; more options will be added in the future Lesser-used options clutter the interface and reduce dock space efficiency Add an “Additional Options” expander for lesser-used items 4. Separate Dynamics ‘Enable Dynamics’ contains the ‘Fade and Colour’ options The ‘Fade and Colour’ options take up a lot of space, and do not need to be visible all the time. Add a “Dynamic Fade and Colour” expander, visible when Enable Dynamics is checked 5. Compact Resource Chooser Picking a resource such as a brush or a dynamic is done via a chooser, see the Paintbrush GUI The chooser is takes up two rows of the dockable due to a label above the combo box. The icons on either side are distorted to fill the gap, which looks bad. GUI space is wasted Remove the label and the chooser becomes compact. The purpose of the chooser is self evident and does not need a label 6.Smooth Stroke Position ‘Smooth Stroke’ is in low down in the dock It’s a frequently used option for painting Move higher up the dock "},"title":"Paintbrush-Options"},"/test/folder/presets-restore/":{"data":{"":"","#":"Objective Improve the usability of Tool Presets in Artbox.\nKey Concepts and Definitions Tool Presets: A saved set of Tool Options, with an embedded filter that can be configured in the Tool Preset Editor. Related Links Branches: Artbox and feature-presets-restore Design Revisions Revision Current Design Issues Changes 1. Double click active preset to restore Clicking an active preset has no affect User has to select another preset then reselect to restore options to the save preset Double clicking restores the preset "},"title":"Presets-Restore"},"/test/folder/resource-control/":{"data":{"":"","#":"Objective Improve the usability and data saving of resources and Tool Presets in Artbox.\nKey Concepts and Definitions Resources: Tool Presets, Patterns, Gradients, Brushes, Palettes, and Dynamics. Tool Options: The set of adjustable parameters presented to the user for each Tool in Artbox. Tool Presets: A saved set of Tool Options, with an embedded filter that can be configured in the Tool Preset Editor. Related Links Tool-Presets-Revision Design Revision: Brushes Dialog and Brush Editor Branches: Artbox and feature-resource-control Revised Preferences Preferences -\u003e Folders Show the Copy Resource Location menu item Save resource changes on exit ","design-revisions#Design Revisions":" Revision Current Design Issues Changes 1. Deactivate automatic resource saving Saves are done when GIMP exits Tweaks to resources in session can corrupt carefully set up tools with unwanted changes. A Preference to ‘Save resource changes on exit’ 2. Save specific resource changes immediately Saves are done when GIMP exits Changes to resources are lost if GIMP crashes or exits with a crash. Save immediately when clicked 3. Save As Saves are done with default naming The name of the saved resource is not the same as the filename, this is confusing. Save immediately with a naming option, Save As… 4. Save All If saves are done by the user on demand, as described in (2) or (3), a new issue arises Changes to resources may be forgotten during the session. Saving one by one is error prone and time consuming Add ‘Save all the active tool assets’ button and a ‘Save all changes’ button on the Preset Editor 5. Simpler Menu Menu item ‘Copy Resource Location’ exists in several menus Not used by most users, creates menu clutter A Preference to ‘Show Copy Resource Location menu item’ 6. Button Bar and Menu Revised See menu items and Button Bar GUI in GIMP Confusing item placement, Button Bar GUI out of step with updates from (1-5) Apply a consistent menu item position, and arrange Button Bars to support the changes 7. Edit Brush deals with Parametric and Image types See Brushes Menu items Confusion over brush types Double clicking an image type opens the image for editing, Double clicking a parametric type opens the Brush Editor 8. Inform the user about locked resources Folder locked resources can not be edited User confusion An informative message is displayed in the Brush Editor if the resource is locked 9. Copy and Paste as New Brush New Feature Create a brush from the active drawable Added to the Brushes Menu via a Script-Fu plug-in "},"title":"Resource-Control"},"/test/folder/script-fu/":{"data":{"":"","#":"Objective Extend Script-Fu to include additional functions that help the user.\nKey Concepts and Definitions Script-Fu: A scripting language based on Scheme Related Links Branches: Artbox and feature-additional-script-fu Additional Procedures Command Purpose (gimp-context-get-display) Get the active display ID (gimp-context-erase-paint-mode-toggle) Toggle the paint mode to erase (gimp-context-eraser-toggle) Toggle the tool to the eraser. (gimp-items-set-visible) Set the visibility of a vector list of items "},"title":"Script-Fu"},"/test/folder/toolbox/":{"data":{"":"","#":"Objective Improve the usability of the Toolbox.\nKey Concepts and Definitions Flowbox: A flexible container that one to three widgets are arranged in. The FG/BG colour area, the active resources and active image. Tool Palette: The grid of tool buttons, Move Tool, Paintbrush Tool ect. FG/BG: The active foreground \u0026 background colour widget. Related Links Branches: Artbox and feature-toolbox Revised Preferences Preferences -\u003e Toolbox -\u003e Appearance Show colour, active resources and active image Show only colour, set preferred position and scale. Toolbox placement relative to the tool buttons Top Bottom Left Right Scale the colour widget Design Revisions Revision Current Design Issues Changes 1. Remove Flowbox The Flowbox is positioned beneath the Tool Palette The Flowbox takes up a large amount of GUI space. If only one or two elements are preferred, the GUI space is empty. The size of the FG/BG is restricted by the arrangement. Allow the user to create a simpler toolbox with no wasted space by removing the Flowbox and keeping the FG/BG widget 2. Position and scale the FG/BG widget. New Feature The FG/BG widget may be poorly positioned taking up GUI space. It may be too small on HDPI displays Allow the user to position and scale the FG/BG widget relative to the Tool Palette "},"title":"Toolbox"},"/themes/folder/":{"data":{"":"","#":"Introduction Personalize your creative experience with a selection of custom themes for GIMP and Artbox! Whether you prefer a high-contrast interface for easy visibility, a warm and cozy palette, or a dark theme for a more focused environment, these themes offer a variety of options to suit your style. Easy to install and compatible with multiple platforms, these themes will help you tailor the look and feel of your Artbox interface to match your preferences.\nDownload Once the themes.zip has downloaded, extract the themes directory. Point Artbox at that folder by adding it here: Edit-\u003ePreferences-\u003eFolders-\u003eThemes Restart Artbox and find the new themes in Edit-\u003ePreferences-\u003eInterface-\u003eTheme Themes Structure Inside the default theme folder are CSS files and assets. Color definitions for the theme are in ‘color-definitions.css’. Assets for a theme are in the assets folder, they are assigned by the CSS file ‘color.css’ in the ‘stylesheets’ folder. The stylesheets folder contains:\nColor: assignments for color, borders and opacity. Layout: assignments for margins, padding and sizing. Font: assignments for size, style and weight. Round: assignments for rounded corners. "},"title":"Themes"},"/themes/folder/dark/":{"data":{"":" "},"title":"Dark"},"/themes/folder/default/":{"data":{"":" "},"title":"Default"},"/themes/folder/high-contrast/":{"data":{"":""},"title":"High Contrast"},"/themes/folder/system/":{"data":{"":""},"title":"System"},"/themes/folder/warm/":{"data":{"":""},"title":"Warm"}}